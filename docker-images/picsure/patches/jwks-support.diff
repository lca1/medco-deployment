diff --git a/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWKSKeyResolver.java b/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWKSKeyResolver.java
new file mode 100644
index 0000000..ad5f15f
--- /dev/null
+++ b/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWKSKeyResolver.java
@@ -0,0 +1,105 @@
+package edu.harvard.dbmi.avillach.security;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import edu.harvard.dbmi.avillach.PicSureWarInit;
+import io.jsonwebtoken.Claims;
+import io.jsonwebtoken.JwsHeader;
+import io.jsonwebtoken.SigningKeyResolverAdapter;
+import io.jsonwebtoken.impl.Base64UrlCodec;
+import io.jsonwebtoken.impl.DefaultClaims;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.util.EntityUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.annotation.Resource;
+import java.math.BigInteger;
+import java.security.Key;
+import java.security.KeyFactory;
+import java.security.PublicKey;
+import java.security.spec.RSAPublicKeySpec;
+import java.util.HashMap;
+import java.util.Map;
+
+import static edu.harvard.dbmi.avillach.util.Utilities.applyProxySettings;
+import static edu.harvard.dbmi.avillach.util.Utilities.buildHttpClientContext;
+
+public class JWKSKeyResolver extends SigningKeyResolverAdapter {
+
+    private Logger logger = LoggerFactory.getLogger(JWKSKeyResolver.class);
+
+    private String jwksUrl;
+
+    /**
+     * Resolved keys cache.
+     * Key ID -> Public Key
+     */
+    private Map<String, Key> keyCache = new HashMap<>();
+
+    private static JWKSKeyResolver instance = new JWKSKeyResolver();
+
+    static JWKSKeyResolver getInstance(String jwksUrl) {
+        instance.jwksUrl = jwksUrl;
+        return instance;
+    }
+
+    @Override
+    public Key resolveSigningKey(JwsHeader header, String plaintext) {
+        return resolveSigningKey(header, new DefaultClaims());
+    }
+
+    @Override
+    public Key resolveSigningKey(JwsHeader jwsHeader, Claims claims) {
+        String kid = jwsHeader.getKeyId();
+
+        if (keyCache.containsKey(kid)) {
+            return keyCache.get(kid);
+        }
+
+        ObjectMapper json = PicSureWarInit.objectMapper;
+        CloseableHttpClient client = PicSureWarInit.CLOSEABLE_HTTP_CLIENT;
+        CloseableHttpResponse response = null;
+        HttpGet get = new HttpGet(jwksUrl);
+        applyProxySettings(get);
+
+        try {
+            response = client.execute(get, buildHttpClientContext());
+            if (response.getStatusLine().getStatusCode() != 200) {
+                logger.error("resolveSigningKey() error back from server ["
+                        + jwksUrl + "]: " + EntityUtils.toString(response.getEntity()));
+                return null;
+            }
+
+            JsonNode responseContent = json.readTree(response.getEntity().getContent());
+            for (final JsonNode keyObj : responseContent.get("keys")) {
+                if (keyObj.get("kid").asText().equals(kid)) {
+                    Base64UrlCodec b64Codec = new Base64UrlCodec();
+                    BigInteger n = new BigInteger(1, b64Codec.decode(keyObj.get("n").asText()));
+                    BigInteger e = new BigInteger(1, b64Codec.decode(keyObj.get("e").asText()));
+
+                    KeyFactory kf = KeyFactory.getInstance("RSA");
+                    PublicKey key = kf.generatePublic(new RSAPublicKeySpec(n, e));
+
+                    keyCache.put(kid, key);
+                    return key;
+                }
+            }
+
+            logger.error("resolveSigningKey() key ID not found");
+
+        } catch (Exception ex) {
+            logger.error("resolveSigningKey() Exception when retrieving JWKS url: " + ex.getMessage());
+        } finally {
+            try {
+                if (response != null)
+                    response.close();
+            } catch (Exception ex) {
+                logger.error("resolveSigningKey() Exception when closing http response: " + ex.getMessage());
+            }
+        }
+        return null;
+    }
+}
diff --git a/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWTFilter.java b/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWTFilter.java
index e894851..e02f953 100755
--- a/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWTFilter.java
+++ b/pic-sure-api-war/src/main/java/edu/harvard/dbmi/avillach/security/JWTFilter.java
@@ -55,6 +55,8 @@ public class JWTFilter implements ContainerRequestFilter {
 	private String clientSecret;
 	@Resource(mappedName = "java:global/user_id_claim")
 	private String userIdClaim;
+	@Resource(mappedName = "java:global/jwks_url")
+	private String jwksUrl;
 
 	@Inject
 	PicSureWarInit picSureWarInit;
@@ -79,8 +81,10 @@ public class JWTFilter implements ContainerRequestFilter {
 
 			if (PicSureWarInit.VERIFY_METHOD_TOKEN_INTRO.equalsIgnoreCase(picSureWarInit.getVerify_user_method())) {
 				authenticatedUser = callTokenIntroEndpoint(requestContext, token, userIdClaim);
-			} else {
+			} else if (PicSureWarInit.VERIFY_METHOD_LOCAL.equalsIgnoreCase(picSureWarInit.getVerify_user_method())) {
 				authenticatedUser = callLocalAuthentication(requestContext, token);
+			} else {
+				authenticatedUser = callLocalJwksAuthentication(requestContext, token);
 			}
 
 			if (authenticatedUser == null) {
@@ -246,4 +250,13 @@ public class JWTFilter implements ContainerRequestFilter {
 
 		return userRepo.findOrCreate(new User().setSubject(subject).setUserId(userId));
 	}
+
+	private User callLocalJwksAuthentication(ContainerRequestContext requestContext, String token) throws JwtException{
+		Jws<Claims> jws = Jwts.parser().setSigningKeyResolver(JWKSKeyResolver.getInstance(jwksUrl)).parseClaimsJws(token);
+
+		String subject = jws.getBody().getSubject();
+		String userId = jws.getBody().get(userIdClaim, String.class);
+
+		return userRepo.findOrCreate(new User().setSubject(subject).setUserId(userId));
+	}
 }
